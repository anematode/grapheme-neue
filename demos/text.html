<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Elements</title>
</head>
<body>

<script src="test_setup.js"></script>

<noscript id="setup">
    let renderer = new Grapheme.TextRenderer()

    // temp stupidity
    const ctx = renderer.ctx

    document.body.appendChild(renderer.canvas)
    const canvas = ctx.canvas

    const text = "Handling a rejected promise in each .then() has consequences further down the promise chain. Sometimes there is no choice, because an error must be handled immediately. In such cases we must throw an error of some type to maintain error state down the chain. On the other hand, in the absence of an immediate need, it is simpler to leave out error handling until a final .catch() statement. A .catch() is really just a .then() without a slot for a callback function for the case when the promise is resolved."

    text.split(' ').forEach(text => renderer.draw( { text, font: "12px Verdana" } ))

    renderer.runQueue()

    /*let packer = new Grapheme.DynamicRectanglePacker()

    packer.queueRectangle("red", 100, 120)
    packer.queueRectangle("blue", 100, 120)
    packer.queueRectangle("green", 100, 120)

    packer.pack()


    function drawRectangles () { ctx.clearRect(0, 0, canvas.width, canvas.height)
      for (const [ color, rect ] of packer.rects) {
        ctx.fillStyle = color;
        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
        console.log(rect)
      }
    }

    drawRectangles()*/
</noscript>


</body>
</html>
