\documentclass{article}
\usepackage{amsmath}
\usepackage{amsfonts}

\newcommand{\NaN}{\texttt{NaN}}
\newcommand{\allfp}{\mathbb{F}_\text{all}}
\newcommand{\definedfp}{\mathbb{F}_\infty}
\newcommand{\finitefp}{\mathbb{F}}

\begin{document}

\title{Grapheme: An Online Graphing Calculator}
\author{Timothy Herchen}
\date{October 2020}

\begin{titlepage}
\maketitle
\end{titlepage}

\tableofcontents
\newpage

\section{Floating-point Operations}

Grapheme uses double-precision floating-point arithmetic for most calculations, since this functionality is provided by JS directly and is highly optimized. When the calculator is directed to evaluate $3 \cdot 4$, it uses the JS $*$ operator which maps directly to a machine instruction. There is no point in using single-precision arithmetic, as these are the same speed on modern processors and JS has no facilities besides asm.js to use this format.

There are some important limitations in double-precision FP. Some of the most obvious are the inability to express integers greater than $2^{53}\approx 9.007\cdot 10^{15}$, numbers greater than about $2^{1023}\approx 1.798 \cdot 10^{308}$, and positive numbers smaller than $2^{-1074}\approx 4.941\cdot 10^{-324}$. While arbitrary-precision arithmetic may be eventually implemented, this is difficult and thus we will try to do our best using the existing system.

Some conventions:
\begin{enumerate}
  \item $\pm\infty$ and $\NaN$ are known as \textit{special numbers}.
  \item Floating-point numbers that are not special numbers are \textit{finite numbers}.
  \item Denormal numbers and normal numbers are named as usual.
  \item $\NaN\neq\NaN$, contrary to the mathematical definition of equality. However, $\NaN\simeq\NaN$. For all other purposes, $=$ and $\simeq$ are equivalent.
  \item There is only one $\NaN$ value, because the standard does not specify the existence of qNaNs, sNaNs and the like.
  \item The set of all double-precision floating-point numbers, including the special numbers, is denoted $\allfp$.
  \item $\allfp$ without the special numbers is denoted $\finitefp$. Without only $\NaN$, it is denoted $\definedfp$. Thus, $\finitefp\subset\definedfp\subset\allfp$.
\end{enumerate}

\subsection{Directed Rounding}

Per the ECMAScript standard, JS operations all use round-to-nearest, ties-to-even. That means that if the mathematical result of an operation is, say, $3.261$, and the nearest permitted floats are $3.26$ and $3.27$, the operation will return $3.26$. Unfortunately, JS does not provide facilities to set the rounding mode, which is understandable given the niche use of these modes.

\subsection{Intelligent Pow}

Among the real numbers, exponentiation is straightforward for positive bases, but rather complicated for negative bases. Negative bases raised to a rational power are variously positive, negative or undefined, depending on the fraction. Among $\finitefp$, however, negative bases raised to any power are undefined. This can be logically seen from the fact that all floating-point numbers are rational numbers. But the number $0.3333333333333333\in\finitefp$ likely refers to $\frac{1}{3}$, and so does $0.33333333333333326$, but probably not $0.3333333333001$.

\subsubsection{Doubles to Rationals}

There are two competing interests: one, to correctly recognize mathematical rational numbers that would be reasonably encountered in a graphing session, and two, to make coincidences that lead to the recognition of irrational numbers as rational unlikely. We restrict our further work to the positive domain, since this makes our life far easier. In other words, we want to find a reasonable function $d : \finitefp_{>0} \to \mathbb{Z}^2$, so that the resulting numeratorâ€“denominator pair corresponds closely to the floating-point number argument.

To do this, we make some stipulations.

\begin{enumerate}
  \item There are at most $\frac{1}{1000}$ of floating-point numbers in any range $\left(2^n, 2^{n+1}\right)$ are classified as rational. This makes it unlikely that a randomly-generated real number will be considered rational.
  \item The floating-point numbers corresponding to a rational number $\frac{p}{q}$ are at most those inside \texttt{RealInterval.from(p/q)}; in other words, they are either \texttt{p/q} as evaluated by JS, or the preceding or succeeding float.
  \item There must be no intersections between these intervals.
  \item We assert that the numerator and denominator be less than or equal in magnitude to Number.MAX_SAFE_INTEGER ($2^{53}-1$), which makes our life easier (and such numbers are the majority of rational numbers we'd encounter).
\end{enumerate}

For example, \texttt{1/3} evaluates to the floating-point number $0.3333333333333333$. The preceding and succeeding members of $\finitefp$, namely $0.33333333333333337$ and $0.33333333333333326$ should also correspond to the same number, but no other numbers should correspond to the rational number $\frac{1}{3}$. Because the spacing between floating-point numbers varies, we split up our recognition algorithm over each of the $2046$ sets $\left(2^n, 2^{n+1}\right)$ for $-1022\leq n\leq 1023$ available to floating-point numbers. (Denormalized numbers are ignored, since they are too small.)

The minimum returnable rational number is $\frac{1}{2^{53}-1}$, which means that all numbers smaller than $\frac{1}{2^{53}}$ may be considered irrational. The minimum possible distance between two floating-point numbers in a given range is $2^{n-52}$. The maximum error of \texttt{p/q} from its mathematical value, since it is round-to-nearest, is $2^{n-53}$. Thus, the minimum distance between two allowed fractions must be greater than

$$\underbrace{2\cdot 2^{n-53}}_{\text{rounding}}+\underbrace{3\cdot 2^{n-52}}_{\text{interval widths}} = 2^{n-50}$$

to comply with stipulation #2 and #3. We wish to support all (reduced-form) rational numbers $p/q$ with $q \leq d_n$ in a range $[2^n, 2^{n+1})$, where we choose $d_n$ intelligently. The minimum distance between any two floating-point numbers 

Once tagged real numbers are implemented, this issue should be less important, but will still likely be used as a fallback.

\section{Interval Arithmetic}

\end{document}
